---
title: "Иммутабельные классы Java - наименование сеттеров"
tags: ['java', 'immutable', 'conventions']
categories: ['java']
description: "Какие варианты наименования существуют в иммутабельных классах? Рассмотрим распространенные соглашения по шаблонам сеттеров в иммутабельны классах Java."
date: 2021-10-20T16:26:04+05:00
tableOfContents : false
toc : false
---

{{< callout type="info" >}}
<i class="fas fa-language"></i> Перевод статьи <a href="https://programming.guide/immutable-setters-naming-conventions.html" target="_blank">Immutable Setters: Naming Conventions</a>
{{< /callout >}}

Сеттер поля для иммутабельного объекта отличается от обычного сеттера. Так как не изменяет объект, а создает новый с измененым параметром класса. Это веская причина для изменения нейминга методов.

В этой статье список различных возможных соглашений для иммутабельных классов, с примерами на Java.

## withX(...)

Самый распространенный в настоящее время шаблон для сеттеров. Например, это наименование используется по умолчанию для генерируемых сеттеров в фреймворке <a href="https://immutables.github.io/" target="_blank">Immutables</a>. Пример:

```java
Foo newFoo = foo.withX(1047);
```

В `Immutables` возможно изменить шаблон наименования через аннотацию `@Value.Style`, опция называется `with="..."`, лишний раз подчеркивает `with` как соглашение по-умолчанию.

Соглашение использовать `with` широко распространено, примеры сеттеров вы сможете найти в библиотеках <a href="https://github.com/google/guava" target="_blank">Guavа</a> и <a href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html" target="_blank">Java Time</a>.

## Just x(...)

Другой подход, заключается в полном отсутствии префикса. Пример использования найдете также в `Immutables` при сборке объекта, используя паттерн Builder. Пример:

```java
Foo foo = ImmutableFoo.builder()
                      .x(1047)
                      .y("Hello World")
                      .build();
```

Если используете такой вариант наименования, то посмотрите также и вариант геттера в таком же стиле. Это будет перегруженный метод без аргументов, даже если не используется паттер Builder в классе. Пример:

```java
Foo newFoo = foo.x(5);  // setter - один аргумент
int x = newFoo.x();     // getter - без аргументов
```

Такое соглашение использует фреймворк <a href="https://sparkjava.com/" target="_blank">Java Spark</a>.

## setX(...)

Некоторые API используют стандартные наименования сеттеров для иммутабельных классов. Такие имена методов неочевидны, так обращаясь к объекту мы не может сразу отличить иммутабельность, а для нового участника проекта это будет каждый раз сюрприз. При этом и в стандартном JDK такое подход также использутся. 

Работает с объектом типа <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.html" target="_blank">BigInteger</a> и пишем код для установки значения:

```java
bigInt.setBit(2);
```

...и это пример ошибки, так как такой метод не изменяет состояние объекта, а создает новый. При использовании сеттера в таком виде возвращаемый объект не используется, хотя и создается. Правильно использовать сеттер:

```java
BigInteger newBigInt = bigInt.setBit(2);
```

## deriveX(…)

Для подчеркивания факта создания нового объекта _(derived - производный)_, вы можете использовать шаблон `deriveX(…)`. Иммутабельный класс `Font` в Java API следует этому правилу. Если вы хотите создать новый шрифт, например, с указанием размера, используйте:

```java
Font newFont = font.deriveFont(newSize);
```

Класс `Font` используется с незапамятных времен, а метод `deriveFont(...)` c JDK 1.2.
В настоящее время данный формат нейминга не рапространен.

## Иммутабельный объект, как аргумент

Когда иммутабельный объект является аргументом метода и влияет на вызываемый объект, то
сеттер не является сеттером по сути. В этом случае не требуется префикса вовсе. Например, умножение чисел:

```java
BigDecimal newBigDec = bigDec.multiply(BigDecimal.TEN);
```

...сигнатура похожа не сеттер, при этом имя метода `multiply` точно описывает действие
и данный нейминг в этом случае подходит лучше других альтернатив.

Аналогично `String.substring`, `Path.resolve` и не только.
